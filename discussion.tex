%\vspace{-0.2cm}
\section{Discussion}\label{sec-discussion}

%Next we discuss 
%This section discusses the limitations of \@approach. 
Like any approach relying on static analysis, \@approach is subject
to false positives. A promising avenue of future research is
to complement \@approach with dynamic analysis techniques.
Essentially, it should be possible to utilize dynamic
analysis techniques to automatically verify
incompatibilities identified through our conservative,
static analysis based, incompatibility detection technique,
further alleviating the burden of manual analysis.

As explained in Section~\ref{sec-results}, the majority of the
false alarms are due to a limitation in \@approach regarding
dynamically-generated classes (e.g., {\sf WebView\$1}) that
correspond to anonymous inner class declarations.  When
analyzing the code of each app, \@approach only explores the
explicit classes defined in the app, ignoring the
dynamically-generated classes. Thus, any callback or method
defined inside an anonymous inner class is invisible to
\@approach and is not included in the analysis. We plan to
address this limitation in the future by including the
dynamically-generated class definitions as well.


\begin{comment}
%\commentcs{

During development, we also encountered a false negative in
\emph{Padland}~\cite{padland}.  Huang et al. reported that
there is a callback API incompatibility in this app. There
is also a bug report on it. However, \@approach did not
initially detect any incompatibility issue. We then manually
inspected the call-graph generated by \textsc{Jitana}.
Again, we found no such incompatible API call in the graph.
This clearly explained why no issue was detected. Further
inspection, however, revealed that \emph{Padland} employs
two Dex files, and \@approach only analyzed the main Dex
file; however, the incompatibility is in the second Dex
file. We then reconfigured \@approach to analyze information
of all Dex files in an app and we were able to detect this
incompatibility.

%}

\commentcs{
We initially anticipated that apps that have been
specified to support wider ranges of API levels would
likely encountered more API incompatibility issues.
However, the experimental result clearly indicates that
such a correlation does not exist. The two apps with
most detected incompatibility issues support the ranges
of 10 (\emph{MaterialFBook}) and 8 (\emph{AFWall}) API
levels, respectively.  On the other hand, the two apps
that support the widest ranges of API level (15 for
\emph{SurvivalManual} and 14 for \emph{Simple
Solitaire}) only show 0 and 1 incompatibility issues,
respectively.
}

%As mentioned in Section~\ref{sec-eval}, \@approach reported
%a few number of false positives and negatives. The false
%positives identified in the {\it KolabNotes} app stem from
%its use of an external Java library, the methods of which
%GAINDroid incorrectly interpreted as API methods, resulting
%in false positives when those methods did not appear in the
%API database. Another false positive, in {\it
%SimpleSolitaire}, is due to a mistaken decoding of a call
%to {\sf Checkable.setChecked} (API 1) as a call to {\sf
%TwoStatePreference.setChecked} (API 14).

%The remaining errors---all five false negatives and one false positive---are due to a limitation in \@approach regarding anonymous inner classes. When analyzing the code of each app, \@approach only explores the explicit classes defined in the app, ignoring the dynamically-generated classes (e.g., {\sf WebView\$1}) that correspond to anonymous inner class declarations. Thus, any callback or method defined inside an anonymous inner class is invisible to \@approach and is not included in the analysis, resulting in the false negatives and the remaining false positive. We plan to address this limitation in the future by including the dynamically-generated class definitions as well.

Looking forward, as Android continues to add and deprecate
APIs as part of platform evolution, we also need to update
the database used by \@approach.  Such evolution may also
require that apps be reanalyzed to ensure API compatibility.
Because \@approach can perform analysis efficiently,
re-analyzing apps should only be quite feasible due to small
analysis time.

\commentcs{Android is trying to decrease API and permission
incompatibilities by enforcing new development rules. Google
Play recently required that new apps target at least Android
API level 26 and app updates target Android API level
26~\cite{googleIncomp} and Android 9 (API level 28)
introduced a new restriction regarding the use of hidden
APIs~\cite{googleHidden}.  Apps uploaded to other
repositories such as \cite{fdroid} and \cite{bazaar} could
still present runtime failures.}

\end{comment}
