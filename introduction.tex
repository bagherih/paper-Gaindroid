\section{Introduction}\label{sec-intro}
\sloppy
Android is the leading mobile operating system representing over 80\% of the
market share~\cite{androidmarketstatistics}. The meteoric rise of Android is
largely due to its vibrant app market~\cite{googleplayapps}, which currently
provisions nearly three million apps, with thousands added or updated on a
daily basis.  Android apps are developed using an \emph{application development
framework} (ADF) that ensures apps devised by a wide variety of suppliers can
interoperate and coexist by using a shared framework. 
An ADF exposes well-defined application programming interfaces (APIs) that manifest the set of extension points for application-specific logic, setting it apart from traditional software systems realized as a monolithic, independent piece of code.

The Android ADF frequently evolves, with hundreds of releases from multiple device vendors since 2010~\cite{AndroidReleases}.
Such rapid evolution leads to incompatibilities in Android apps targeted to older versions of the framework.  
As a result, defects and vulnerabilities continue to plague the dependability and security of Android devices and apps, especially following ADF updates~\cite{linares2014api,Update4}. 
A recent industry study found that 23\% of Android apps behave differently after a framework update, and around 50\% of the Android updates have caused instability in previously working apps and systems~\cite{Helppi2014}. 
This has been referred to as ``death on update''~\cite{death1,death2,death3,death4,iOS,youtube}.

Recent research efforts have studied such compatibility issues~\cite{huang2018understanding,wei2016taming,wu2017measuring}, but existing detection techniques target only certain types of APIs.  
For example, Huang et al.~\cite{huang2018understanding} only targets API callback related to object lifecycles, which require significant manual input to identify~\cite{huang2018understanding,wu2017measuring}.
Furthermore, as part of Android ADF version 6.0 (API level 23), Google introduced a dynamic permission system.
In earlier versions, the permission system was entirely static, with permissions granted as apps are installed.
The new system allows users to grant or revoke permissions at runtime~\cite{permissiongroups}.
This new system creates a new class of permissions-related incompatibility issues, none of which are detected by state-of-the-art incompatibility detection techniques.
The state-of-the-art compatibility detection techniques also suffer from acknowledged frequent ``false alarms'' because of the coarse granularity at which they capture API information.  
The lack of proper support for detecting compatibility issues can increase the time needed to address such issues, in some cases longer than six  months~\cite{siliconangle}.
Finally, these techniques~\cite{huang2018understanding,he2018understanding} face difficulties analyzing large apps due to directly loading both the app and the entire code base for each ADF version during analysis.

%\commentty{what about scalability issues faced by existing work since high scalability is one of the contributions of GainDroid?}



%\sloppy In this paper, we present a \textbf{g}eneral, \textbf{a}utomated
\sloppy 
In this paper, we present a scalable, \textbf{a}utomated
\textbf{i}ncom\-patibility \textbf{d}etector for Android, dubbed \@approach, which automatically 
%\sloppy In this paper, we present \@approach (\textbf{G}eneral, fully \textbf{A}utomated \textbf{I}ncompatibility \textbf{N}otifier for And\textbf{DROID}), which automatically %detects compatibility issues regarding the use of all Android APIs and the new runtime permissions system. \commentty{through static analysis?}
detects all types of API- and permission-induced mismatches.
Existing state-of-the-art compatibility detection techniques
require to either analyze the entire ADF codebase or manually model common compatibility callbacks of ADF classes, prior to detecting incompatibilities~\cite{huang2018understanding,lili2018cid,he2018understanding};
as such they face serious scalability issues that limit their abilities to detect complex types of incompatibilities. 
\@approach overcomes such scalability issues by incrementally loading and analyzing only those classes actually loaded by the runtime, using reachability analysis to find all pertinent classes.


%Different from the state-of-the-art compatibility detection techniques that rely on the traditional compiler-based approaches for static analysis~\cite{huang2018understanding,lili2018cid}, \@approach takes a class loader-based analysis approach that gradually loads and analyzes classes, wherein a reachability analysis is leveraged to stumble on all pertinent classes. \@approach then analyzes the identified API call sites and their concomitant conditions to effectively detect compatibility issues regarding the use of all Android APIs and the new runtime permissions system.



%\@approach has several advantages over existing work. First, unlike prior techniques that focus on specific types of APIs, our approach has the potential to greatly increase the scope of analysis by automatically and effectively analyzing all of the APIs in an ADF version. Second, \@approach also analyzes platform code to uncover compatibility issues that exist within the framework; these issues cannot be detected by analyzing only the application code---an approach commonly taken by the state-of-the-art incompatibility detectors~\cite{huang2018understanding,linttips, lili2018cid}.
%\commentty{We need to revise the above sentence ---  ICSE reviewer 1 says CiD does not analyze only the application code.}
%Third, incrementally loading and analyzing classes allows our technique to be remarkably faster and more scalable than the state-of-the-art in compatibility detection.

%\textcolor{blue}{ \@approach has several advantages
%over existing work.  First, unlike prior techniques
%that focus on specific types of APIs, our approach has
%the potential to greatly increase the scope of analysis
%by automatically and effectively analyzing all of the
%APIs in an ADF version.  Second, incrementally loading
%and analyzing classes allows our technique to be
%remarkably faster and more scalable than the
%state-of-the-art in compatibility detection.  Third,
%\@approach holistically analyzes application and ADF in
%tandem by gradually loading and analyzing classes as
%needed during the compatibility analysis. \@approach
%analysis, thus, can seamlessly move between the
%application code and the ADF code during the
%compatibility analysis.  Whereas prior techniques first
%analyze the ADF code, the results of which are
%subsequently used to resolve the API
%usages~\cite{huang2018understanding,linttips,
%lili2018cid}.  }

\@approach has several advantages over existing work.
First, \@approach holistically analyzes the application and ADF in tandem by gradually loading and analyzing reachable classes during the compatibility analysis.
%\@approach analysis, thus, can seamlessly move between the application code and the ADF code during the compatibility analysis.  
Prior techniques require a costly separate analysis of the ADF code first, using the results to resolve API usages~\cite{huang2018understanding,linttips, lili2018cid}. 
Second, by actually analyzing app and ADF code, our approach has the potential to greatly increase the scope of analysis by automatically and effectively analyzing \emph{all} code in the utilized APIs in an ADF version.  
Prior techniques only focus on specific types of APIs.  
Third, incrementally loading and analyzing classes allows our technique to be remarkably faster and more scalable than the state-of-the-art in compatibility detection.  


Our evaluation of \@approach against the state-of-the-art analysis techniques indicates it is up to 3 times more accurate than other incompatibility detection techniques (based on $\text{F}_1$ score). % successful in detecting
%compatibility issues among thousands of real-world app, while issuing significantly fewer
%(11-52\%) false alarms.  
It also successfully detects
permission-induced mismatches that cannot be
detected by state-of-the-art techniques. 
Finally, \@approach is also up to 8.3 times (four times on average)
faster than the state-of-the art techniques. 


%\commentty{Can we put the actual numbers here? E.g., the improvement of incompatibility detection,  performance gain, etc.}
%in the context of real-world Android
%apps collected from variety of repositories have been very
%The results, among other things, corroborate its
%ability to outperform existing analysis techniques both by
%remarkably decreasing the number of false positives and by
%detecting new classes of incompatibilities.  
To summarize,
this paper makes the following contributions:
 
 
\begin{itemize}
%%\vspace{-0.2cm}
%{\color{green} 
\item \textit{General API and permission-induced incompatibility detection algorithms}: We
introduce novel algorithms that automatically detect all types of API incompatibilities and misuses of runtime permission
APIs to which an app may be vulnerable across ADF~versions.


\item \textit{Scalable incompatibility detection approach}:
We introduce a scalable analysis approach that can incrementally
load and analyze classes to handle large scale libraries in 
detecting incompatibility issues. 
%}

\item \textit{Publicly available tool implementation}: We develop a fully~automated
technology, \@approach, that effectively realizes~our
compatibility detection approach. We make \@approach publicly available to the research and education~community~\cite{GainDroid}.



\item \textit{Experiments}: We present results from
experiments run on 3,590 real-world apps and benchmark
apps, corroborating \@approach's ability in (1)
effective compatibility analysis of Android apps,
reporting many issues undetected by the
state-of-the-art analysis techniques; and (2)
outperforming other tools in terms of scalability.

\end{itemize}

%The rest of this paper is organized as follows.
Section~\ref{sec-background} classifies Android compatibility issues.  
Section~\ref{sec-approach} provides an overview of \@approach.
Section~\ref{sec-eval} describes our empirical study, and Section~\ref{sec-results} reports the results. 
Finally, the paper concludes with a discussion of %performance benefits
current limitation, and an outline of related research and future work.
 
